Figure 3. Reference scenario
 94141 (c) Figure 2. Physical fragments Q, k Q’ response to Q response to Q Q response to Q’ query mapping component Q      Q’ Enc_F1 Enc_Fi Enc_Fn Enc_Fj …..  Figure 3. Reference scenario Each fragment F i ∈F is physically stored in a relation, denoted Enc F i , called physical fragment, deﬁned on the set {salt,enc,a i1 ,...,a in } of attributes, where a i1 ,...,a in is the set of attributes inF i and enc is the attribute representing the encryption of all attributes in R except a i1 ,...,a in xor- ed with the salt, a random value different for each tuple and used for preventing frequency-based attacks over the encrypted values.  Physical fragments can be distributed at different servers.  Clearly only fragmentations that do not disclose sensitive associations are acceptable, as captured by the deﬁnition of safe fragmentation.  Deﬁnition 2.3 (Safe fragmentation): Given a relation schema R,aset C of well deﬁned constraints over R, and aset A f of attributes to be fragmented, a fragmentation F of R on A f is said to be safe iff ∀F∈F,∀c∈C :c⊆F. A fragmentation is safe if no fragment is a super- set of any constraint.  We call unsafe any fragmentation that is not safe.  Figure 2 illustrates a possible set of (physical) fragments for the PATIENT relation in Fig- ure 1(a), which corresponds to the safe fragmentation F={{Name},{Occup},{Sickness, ZIP}}.  Figure 3 illustrates the basic scenario we consider.  The users that only need to access the cleartext content of a fragment submit the query directly to the server storing the fragment and receive the result with standard approaches.  Users authorized to access exact queries involving conﬁ- dential information submit their query Q, together with the key k needed for decrypting the data, to a trusted query mapping component.  This component translates query Q into a query Q  on a physical fragment composing the computed fragmentation.  The result is returned to the query mapping component that, if needed, decrypts the tuples and possibly discards spurious tuples.  The ﬁnal plaintext result is then returned to the user.  3. Query cost model Given a fragmentationF of R onA f , any queryQ can be evaluated on each of the fragments composingF because the corresponding physical fragments contain all the attributes of R, either in encrypted or in clear form. 

