Figure 2.  Permission policy integration.
 It is defined as: ( ). ts beh s ⊆   B. Security policy integration  In this section, we define algorithms to automatically  integrate the security policies into the initial specification of  the functional system in the form of an IOSTS by the way of  a specific methodology.  In this paper, we choose OrBAC  [10] syntax to express security policies.  The requirements are  categorized into three types: permission, prohibition and  obligation.  Corresponding to these types of requirements, the  integration algorithms are formed.   1) Permission policy integration: By definition,  permissions relate to the existing states in the initial  functional model.  Considering the IOSTS, permissions  correspond to one (or many) transitions and relate to the  guard G. If the transition related to permission contains no  guard, a guard has to be added.  On the other hand, if a guard  is already exists in the specification, it only needs to add the  security constraints to the guard.  The algorithm is as follows  shown by Fig.2.  2) Prohibitions policy integration: Similar to the  permissions integration, prohibitions integration consists  either of adding a new guard or restraining an existing  one. The corresponding algorithm is shown by Fig.3.  3) Obligations policy integration: In the obligation  requirements integration, a new obligation activity is  created.  This new activity describes a new functional feature  of the system.  To make this possible, the new activity has to  be initially expressed through IOSTS so that the algorithm  can perform an automatic integration.  The obligatory  activity is added into the original functional model starting  from the obligation start location to the obligation end  location.  The algorithm in Fig.4 identifies the transition  which will be split into two (pre/post transitions). Figure 2.  Permission policy integration.  1: ( guard )  2:   ( ( ( ( )) )) 3:  4:  create guard   ( ( ( )) ) 5:  i iii i i i ii i i i G GG V siga role G V sig a role ∃ := ∧ ∨ ¬ ∧¬ := ∨ ¬ ∨ ¬ if then else end if ∪ ∪    

