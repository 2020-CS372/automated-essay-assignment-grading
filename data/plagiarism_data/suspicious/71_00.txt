Figure 2.  Architecture of DA-Based PID controller
 Let us interchange the  order of summations, which gives us                  ()*2 ,,0 11 1 10 0 i j A ij i i MN N Yx x ji i A − − −− − = ∑∑ ∑ == =            ----  (8)    Equation 8 defines a distributed arithmetic computation.   Consider the second term of equation 8 and define it as                           0,0 1 0 ZA ii N x i =− − ∑ =    0 j ∀=                       ----  (9a)    and the first term of the equation as                        , 1 0 ZA iiij N x i = − ∑ =     0 j ∀≠                            ----  (9b)    Sensor  PID Con- troller  Dynamic  Systems        Since x i,j   can take 0 or 1 value only, equation 9b can have  only 2 N  possible values for Z j .  Therefore, they can be pre- computed and stored in an LUT. Each x i , where I = 0 to N - 1, forms the address of the LUT. The output Y can then be  expressed as follows                               *2 1 0 j YZ j M j − = − ∑ =                                  ----  (10)    The result Y can then be computed using shifting and addi- tion operations for all Z j ’s from j th  bit.     2) DA-Based PID Controller: Let us consider the controller  terms given in equation 4(a),(b), and (c).  Assuming that  u c (kT), u c  ((k - 1)T), y(kT) and y((k - 1)T) are M bit numbers  and j represents the j th  bit of the numbers, we have           1 ( ) ( ( )( ) ( )( )) * 2 0 M j PkT K bu kT j y kT j c j − =− ∑ =         ----  (11)    1 ( ) ( (( 1) )( ) (( 1) )( ) 0 M KT IkT I k Tj u k Tj T i j − =− + − ∑ =                                    (( 1) )( )) * 2 j yk T j −−                    -----  (12)                                                                                                                           (( 1 () ( (( 1))() ()() 0 TN dd y TNT NT dd M KT D kT D k T j kT j T j ++ − =−− ∑ =                                    )) (( 1) )( )) * 2 j yk T j −−                ----    (13)    The results of ( Kb u c  (kT)[ j ] – K y(kT)[ j ], [ I ((k - 1)T)[ j ] +  (KT/T i )[ u c  ((k –1)T)[ j ] - y((k - 1)T)[ j ]], and ((T d  / T d  + NT )  D ((k - 1)T)[ j ] - (KT d  N/ T d  + NT ) ((y (kT)[ j ] - y ( ( k - 1)T)  [ j ] )) can be precomputed and stored in 3 LUT’s namely,  LUT P , LUT I , and LUT D .  The contents of the 3 LUT’s are  shown in Tables I, II and III, respectively.  Using the 3 LUT’s  and the corresponding shift-add accumulators (ACCs), the  P(kT), I(kT), and D(kT) terms can be obtained in m clock  cycles.  The main advantage of DA expression given by eq- uations 11, 12, and13 lies in its capability to compute the  PID function utilizing the LUT-rich FPGA.    TABLE I   Contents of LUT P    u c  (kT)[ j ] y(kT)[ j ] LUT P   0 0 0  0 1 - K  1 0 K b  1 1 Kb – K    TABLE II   Contents of LUT I    I((k-1) T ) [ j ] u c ((k- 1)T)[ j] y((k -1)T)[ j  ]  LUT I 0 0 0 0 0 0 1 -(KT/T i ) 0 1 0 KT/T i 0 1 1 0 1 0 0 1 1 0 1 1-(KT/ T i ) 1 1 0 1+(KT/T i ) 1 1 1 1    TABLE III  Contents of LUT D     D((k-1)T )  [ j] y(kT) [j ] y((k-1)T)[j] LUT D   00 0 0 00 1 KT d N/(T d +NT) 0 1 0 -(KT d N/(T d +NT)) 01 1 0 10 0 T d /( T d +NT) 1 0 1 (1+ KN) T d /(T d + NT) 11 0 (1-KN)T d /(T d + NT) 11 1 T d / (T d + NT)   Based on the above equations, the DA implementation of  the PID controller is shown in figure 2. It consists of 4 delay  blocks, 3 LUTs, 3 ACCs, and 2 adders.  The delay blocks 1  and 2 are used to obtain u((k – 1)t)  and y((k – 1)T), respec- tively.  The delay blocks 3 and 4 are used to generate the  terms I((k – 1)T) and D((k – 1)T), respectively.  3 LUTs and 3  ACCs are used to provide the term P(kT), I(kT), and D(kT).   The throughput of this PID implementation is (m + 1) clock  cycles, i.e., m clock cycles to generate the result and one  more clock cycle to update the I((k – 1)T) and D((k – 1)T)  terms.  For the multiplier-based controller throughput is 1  clock cycle.  The latency is also (m + 1) clock cycles, where  as for multiplier-based method, it is 1 clock cycle. 

